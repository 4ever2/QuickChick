* ------------------------ DAY 1 -------------------------

* Introduction  (Intro.v)

a few small examples to illustrate QC's completely automatic behavior,
including Sample, QuickCheck, and Shrinking

a few simple exercises -- find the bug in XX

small examples (lists and similar)

* Coq typeclasses (TypeClasses.v)

core QC typeclasses
  - derived typeclasses (Show) -- maybe this will eventually be a general
    feature of Coq, but for now it's part of QC
  - generator monad
     - basic combinators (elements, oneOf, ...)
     - exercises: build a generator for XX
     - CoArbitrary
     - generators for polymorphic properties (nat, Li-Yao stuff, etc.)
  - shrinking
      - build a custom shrinker for XX
      - question: what is wrong with this shrinker?  
           - might generate the same example
           - might generate larger examples

* ------------------------ DAY 2 -------------------------

* Basic QuickChick Programming (BasicQC.v)

Figure out whether P? notation is actually used here!  If not, can be
skipped/skimmed in the Typeclass part.

** Checkers

the Dec typeclass

   We've said that QuickChickable properties must be "executable."  What
   this means precisely is "decidable," in the sense of the "Dec"
   typeclass. 

Explain Checkable -- a generalization of Dec that carries some extra
structure.  

Explain how simple boolean functions can also be Checkers -- this is the
most low-level and flexible way to create checkers

    (* EX2 (SortQC) *)
    (** Here is an incorrect implementation of insertion sort: *)
    (* NOW: This is a fine exercise for right here, but it could also be
       useful below, where the insert function itself motivates the need
       to test conditional properties, hence generators.  So maybe better
       as _not_ an exercise, actually. *)

    Fixpoint insert x l :=
      match l with
      | [] => [x]
      | y::t => if y <? x then insert x t else x::y::t
      end.

    Fixpoint isort l :=
      match l with
      | [] => []
      | x::t => insert x t
      end.

    (** Write a boolean property that characterizes correct sorting and
        use QuickCheck to find a counterexample.  Fix the bug and use
        QuickChick again to verify that there are no more
        counterexamples.  (Or, if QuickChick notices another bug, keep
        fixing things until it doesn't.) *)

    (* QUIETSOLUTION *)
    Fixpoint member x l :=
      match l with
      | [] => false
      | y::t => orb (beq_nat x y) (member x t)
      end.

    Fixpoint sorted l :=
      match l with
      | [] => true
      | h1::t => match t with
                   | [] => true
                   | h2::t2 => andb (h1 <=? h2) (sorted t)
                 end
      end.

    Definition perm l1 l2 :=
      andb (forallb (fun x => member x l2) l1)
           (forallb (fun x => member x l1) l2).

    (* /QUIETSOLUTION *)
    Definition isortP : list nat -> bool
      (* ADMITDEF *)
      := fun l => andb (sorted (isort l)) (perm l (isort l))
    .
    (* /ADMITDEF *)
    (* QUIETSOLUTION *)
    QuickChick isortP.
    (* Finds a bug! *)

    Fixpoint insert2 x l :=
      match l with
      | [] => [x]
      | y::t => if y <? x then insert2 x t else x::y::t
      end.

    Fixpoint isort2 l :=
      match l with
      | [] => []
      | x::t => insert2 x (isort2 t)
      end.

    Definition insert2P
      := fun x l => andb (sorted (insert2 x l)) (perm (x::l) (insert2 x l)).
    QuickChick insert2P.

    Definition isort2P : list nat -> bool
      := fun l => andb (sorted (isort2 l)) (perm l (isort2 l)).
    QuickChick isort2P.
    (* Finds another! *)

    Fixpoint insert3 x l :=
      match l with
      | [] => [x]
      | y::t => if y <? x then y :: (insert3 x t) else x::y::t
      end.

    Fixpoint isort3 l :=
      match l with
      | [] => []
      | x::t => insert3 x (isort3 t)
      end.

    Definition isort3P : list nat -> bool
      := fun l => andb (sorted (isort3 l)) (perm l (isort3 l)).
    QuickChick isort3P.
    (* /QUIETSOLUTION *)


** Generators

explain the Gen, G, Arbitrary, and Shrink typeclasses

return to the small examples and unpack them

Global Instance testDec {P} `{H : Dec P} : Checkable P :=
  {|
    checker p := _
  |}.

** Shrinking

** More combinators

See the original QuickCheck paper for...
  - generating functions (CoArbitrary, etc.)
  - (what else?)

Exercise: test that the filter function yields a list containing only
elements that test true.

** Implementation

How it works internally.

QuickChick commands must not be in (sections or?) submodules


** Case Study

a typed version of Imp (ints and boolean)
  dynamic failures
  a little static type system
    investigate: can we easily detect issues with progress / preservation?
  maybe a little dynamic IFC analysis

more QC typeclasses
  sized?

ways of measuring distributions
   "Tuning random distributions is 
      - a creative process
      - based on observations
      - highly effective"
   (and see other observations in John's talk)

collect 
  - small example
  - forward pointer to third day?

Defining new one-constructor types to obtain different Gen behaviors (for
example).

(talk about the fact that longer test cases often find examples better --
see John's talk, and perhaps even use the "1-2-3-4-5 in order" example in
detail) 

Sized generators
  - GenSized class
    (there is a LOT to say about sized genreators!)

Polymorphic generators (nat)

custom shrinking

* Mutation testing (Mutation.v)

mutation testing

mutation testing vs collect
  - collect informs about statistics of the distribution
  - mutation testing informs whether the distribution leads to good testing
  - John's x<y example?
  
* ------------------------ DAY 3 -------------------------

* Case study: Vellvm (VellvmQC.v)

* ------------------------ DAY 4 -------------------------

* Generating dependent generators (GenGen.v)

  - Using QuickChick to automatically derive generators satisfying 
    preconditions in the form of inductive datatypes
  - Notation
  - Precise form required from predicates
  - Narrowing caveats (too much backtracking if instantiating too early)
  - Workarounds (group predicates together - commit b2e4ad922e20b87818cb6162d714fe498e4dc356 from DeepSpec demo for an example)

super-simple compiler

case study: Imp+IFC or lambda terms

Zoe-proofs (the relevant typeclasses, mainly, plus just a hint of the
proofs)
  - 1-hour talk based on her section of popl submission

* Closing Comments (Closing.v)

final comments about testing
  - simple properties: very high payoff
      - round trip properties
      - regression testing
  - invariants that are going to be used for proof
  - complete specs may have smaller payoff
  - code coverage is a very bad success metric, but a rather good heuristic
    for when your tests are not good enough  (is there a code coverage tool
    for OCaml?  Yes: bisect_ppx seems to be under active development.)

_________

Random observations:
  - Extraction doesn't work if any definitions are Admitted.  But in a
    testing context, it might actually be better to give them wrong
    definitions (and then discover that fact)!  
